<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>201803JS</title>
</head>
<body>
<!--
Function.prototype.call=function(){
   call方法中的this一定是当前使用call的那个函数
   1.让前面的函数 this执行 this()
   2.call中从第二个参数开始是给this传参数用的
}

f.call()
-->
</body>
</html>
<script>

    Function.prototype.call=function (obj,...args) {
      //...args:将除了第一个参数以外的所有参数获取 变成一个数组
      //this->f
      if(obj==undefined){ //obj:不传 undefined null
        //让f执行 将f中的this变成window
        //给this传参数的时候是将args展开传的
        this(...args);//就相当于 f(), this->window
      }else {
        //将this(这里是f)中的this变成obj
        //给obj所属的原型上增加一个 fn属性值是this代表的函数(这里是f)
        //为了防止在控制台打印能看见fn 我们将其加在原型上
        obj.__proto__.fn=this;//他俩共用一个地址
        obj.fn(...args);//都是只同一个地址的函数执行但是这次this就变成了obj
        //用完了将其删除
        delete obj.__proto__.fn;
      }
    };
    function f(n,m) {
      console.log(n + m);
      console.log(this);
    }
    f.call(null,1,2);// args=[1,2]  f(1,2) ->f(...args)
    f.call(undefined,1);
    f.call({n:1},1,2)




    //let [x,...x1]=[1,2,3,4,5]


    Function.prototype.call=function () {
      var ary=[];
      for (var i=1;i<arguments.length;i++){
        ary[i-1]=arguments[i];
      }
      if(arguments[0]==undefined){
        eval("this("+ary+")");
      }else {
        obj.__proto__.fn=this;
        eval("obj.fn("+ary+")");
        delete obj.__proto__.fn;
      }
    };

    Function.prototype.call=function () {
      var ary=[];
      var obj=arguments[0];
      for (var i=1;i<arguments.length;i++){
        ary[i-1]=arguments[i];
      }
      if(obj==undefined){
        //注意:构造函数得到的函数执行里面的this是window 所以使用变量_this代表call中的this
        (new Function("_this","_this("+ary+")"))(this);
      }else {
        obj.__proto__.fn=this;
        (new Function("obj","obj.fn("+ary+")"))(obj);
        delete obj.__proto__.fn;
      }
    }

    f.call(null,1,2);// args=[1,2]  f(1,2) ->f(...args)
    f.call(undefined,1);
    f.call({n:1},1,2)

</script>
